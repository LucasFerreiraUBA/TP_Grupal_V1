cargar_datos,(arch_codigo, arch_comentarios, arch_reporte, ultimo),crear_arch_datos_funciones,final = ultimo + ",,,",reg_codigo = leer_registro(arch_codigo, final),reg_coment = leer_registro(arch_comentarios, final),funcion_cod, param, modulo, instruc = procesar_codigo(reg_codigo, final),funcion_com, autor, manual, coment = procesar_comentarios(reg_coment, final),nuevo_registro = "FUNCIÓN,Parámetros,Líneas,Invocaciones,Returns,If/elif,"\,"For,While,Break,Exit,Coment,Ayuda,Autor",grabar_registro(arch_reporte, nuevo_registro),while funcion_cod != ultimo and funcion_com != ultimo:,funcion_rep = f"{funcion_cod}.{modulo}",cant_param = contar_parametros(param),cant_lineas, cant_if_elif, cant_for, cant_while, cant_break, \,cant_return = contar_sentencias(instruc),cant_invoc = 0  # no pude crear el algoritmo,cant_exit = 0  # ¿variable exit? ¿función exit?,cant_comentarios = contar_comentarios(coment),ayuda = "Si" if manual != "" else "No",nombre_autor = extraer_autor(autor),nuevo_registro = f"{funcion_rep},{cant_param},{cant_lineas},{cant_invoc}"\,f",{cant_return},{cant_if_elif},{cant_for},{cant_while}"\,f",{cant_break},{cant_exit},{cant_comentarios},{ayuda}"\,f",{nombre_autor}",grabar_registro(arch_reporte, nuevo_registro),reg_codigo = leer_registro(arch_codigo, final),reg_coment = leer_registro(arch_comentarios, final),funcion_cod, param, modulo, instruc = procesar_codigo(reg_codigo, final),funcion_com, autor, manual, coment = procesar_comentarios(reg_coment, final),
contar_comentarios,(anotaciones),crear_arch_datos_funciones,if not anotaciones:,cantidad = 0,else:,cantidad = len(anotaciones.rstrip("\n").split("\n,")),return cantidad,
contar_parametros,(cadena_parametros),crear_arch_datos_funciones,if cadena_parametros == "()" or cadena_parametros == "( )":,cantidad = 0,else:,cantidad = len(cadena_parametros.strip("()").split(",")),return cantidad,
contar_sentencias,(cadena_ordenes),crear_arch_datos_funciones,instrucciones = cadena_ordenes.rstrip("\n").split("\n,"),cant_lineas = cant_retorno = cant_condicionales = cant_mientras = \,cant_para = cant_romper = 0,for linea_codigo in instrucciones:,cant_lineas += 1,if linea_codigo.endswith(":"):,if "if " in linea_codigo or "elif " in linea_codigo:,cant_condicionales += 1,elif "for " in linea_codigo:,cant_para += 1,elif "while " in linea_codigo:,cant_mientras += 1,elif "return " in linea_codigo and "if " in linea_codigo: # retorno if corto,cant_retorno += 1,cant_condicionales += 1,elif "return " in linea_codigo:,cant_retorno += 1,elif "break" in linea_codigo:,cant_romper += 1,return cant_lineas, cant_condicionales, cant_para, cant_mientras, \,cant_romper, cant_retorno,
extraer_autor,(datos_autor),crear_arch_datos_funciones,residuo, nombre = datos_autor.split(":"),return nombre.strip("] "),
grabar_registro,(archivo, linea),crear_arch_datos_funciones,archivo.write(f"{linea}\n"),
leer_registro,(archivo, fin_arch),crear_arch_datos_funciones,linea = archivo.readline(),return linea.rstrip("\n") if linea else fin_arch,
procesar_codigo,(registro, fin_arch),crear_arch_datos_funciones,if registro != fin_arch:,nom_funcion, resto_registro = registro.split(",", 1),param_form, resto_registro = resto_registro.split("),", 1),param_form += ")",nom_modulo, resto_registro = resto_registro.split(",", 1),ordenes = resto_registro,else:,nom_funcion, param_form, nom_modulo, ordenes = fin_arch.split(","),return nom_funcion, param_form, nom_modulo, ordenes,
