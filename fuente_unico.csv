autor_funcion_valor,(registro),corte_control,valor = int(registro[2]),return registro[0], registro[1], valor,
contador_de_invocaciones,(listaOG, listaLL),An_Reu_Cod,dixTOT = {},posLL = 0,for funcion in listaOG:,dixTOT[funcion] = [],posSub = 0,sublis = [],for funcion2 in listaOG:,sublis.append(0),sublis[posSub] = 0,for call in listaLL[posLL]:,if funcion2 == call:,sublis[posSub] += 1,posSub += 1,posLL += 1,dixTOT[funcion] = sublis,del posLL, funcion, posSub, sublis, funcion2, call,return dixTOT,
contador_de_llamadas,(listaOG, dixTOT),An_Reu_Cod,dixRec = {},pos = 0,for recive in listaOG:,listaRec = [],for envia in dixTOT:,if dixTOT[envia][pos] > 0:,listaRec.append('X'),else:,listaRec.append('O'),dixRec[recive] = listaRec,pos += 1,del pos, recive, listaRec, envia,return dixRec,
contar_total,(),corte_control,with open(ARCHIVO,'r') as a:,cantidad = 0,linea = a.readline().split(',')[2],while linea:,cantidad += int(linea),try:,linea = a.readline().split(',')[2],except IndexError:,linea = '',return cantidad,
corte_control,(archivo,archivo_nuevo),corte_control,registro = leer(archivo),acumulado_total = 0,while (registro[0] < MAX_AUTOR):,imprimir("\n", registro[0]+"\n"),escribir("\n", registro[0]+"\n",archivo_nuevo),acumulado_autor, registro , contador_funciones= total_autor(registro, archivo,archivo_nuevo),acumulado_total += acumulado_autor,imprimir("Funciones - lineas: ", acumulado_autor,True,str(contador_funciones),str(round(acumulado_autor/contar_total()*100,2)),'%'),escribir("Funciones - lineas: ", acumulado_autor,archivo_nuevo, True,str(contador_funciones),str(round(acumulado_autor/contar_total()*100,2)),'%'),imprimir("\n Funciones - lineas: ", acumulado_total),escribir("\n Funciones - lineas: ", acumulado_total,archivo_nuevo),
crear_archivo,(diccionario),TPG_parte_5,parte_5 = '',for autor in diccionario:,del diccionario[autor]['lineas_totales'],for funcion in diccionario[autor]:,parte_5 += '{},{},{}\n'.format(autor,funcion,diccionario[autor][funcion]),with open('parte_5.csv','w') as p:,p.write(parte_5),
descripcion_menu,(),main,print('\nIndique con un numero la funcion del programa que desea ver:'),print('1. Panel General de Funciones.'),print('2. Consulta de Funciones.'),print('3. Analizador de Reutilización de Código.'),print('4. Árbol de Invocación.'),print('5. Información por Desarrollador.'),print('6. Reanalizar los programas.'),print('0. Cerrar programa.\n'),
ejecutar,(),TPG_parte_5,crear_archivo(ordenar_por_autor()),ejecutar(),
escribir,(leyenda, dato,archivo_nuevo, separador = False,contador_funciones='',porcentaje='',simbolo_porcentaje=''),corte_control,MAX_AUTOR = "[Autor:zzzzz]",MAX_LINEA = MAX_AUTOR + ",xxx,999",ARCHIVO = "parte_5.csv",archivo_nuevo.write('{} {} {} {} {} {}'.format(contador_funciones,leyenda, dato,porcentaje,simbolo_porcentaje,'\n')),if (separador):,guion = "=" * 55,archivo_nuevo.write('{} {}'.format(guion,'\n')),
escritor,(analiz, listaOG, separador, tab, longitud, dixTOT, dixRec),An_Reu_Cod,n_funcion = 0,for funcion in listaOG:,analiz.write(separador),linea = '',linea += ('|{0:{1}}) {2:{3}}').format(n_funcion, tab, funcion, longitud),n_funcion += 1,contador = 0,for funcion2 in listaOG:,if dixTOT[funcion][contador] > 0 and dixRec[funcion][contador] == 'X':,linea += ('|{0:{1}} ').format('{0}/{1}'.format(dixTOT[funcion][contador], dixRec[funcion][contador]), len(str(contador))),elif dixTOT[funcion][contador] > 0:,linea += ('| {0:{1}} ').format(dixTOT[funcion][contador], len(str(contador))),elif dixRec[funcion][contador] == 'X':,linea += ('| {0:{1}} ').format(dixRec[funcion][contador], len(str(contador))),else:,linea += ('| {0:{1}} ').format('', len(str(contador))),contador += 1,linea += ('|\n'),analiz.write(linea),analiz.write(separador),del funcion, funcion2, contador, n_funcion,return,
generador_de_lista_de_funciones,(),An_Reu_Cod,fuente_unico =  open('fuente_unico.csv','r'),listaOG = [],renglon = fuente_unico.readline().split(","),while renglon != None:,funcion = renglon[0],if funcion != '':,listaOG.append(funcion),renglon = fuente_unico.readline().split(","),else:,renglon = None,fuente_unico.close(),del renglon, funcion,return listaOG,
generador_de_listas_de_llamadas,(listaOG),An_Reu_Cod,fuente_unico =  open('fuente_unico.csv','r'),listaLL = [],renglon = fuente_unico.readline().split(","),while renglon != None:,funcion = renglon[0],if funcion != '':,sublistaLL = procesar_listaFP(renglon, listaOG),listaLL.append(sublistaLL),renglon = fuente_unico.readline().split(","),else:,del funcion,renglon = None,fuente_unico.close(),del renglon, sublistaLL,return listaLL,
generador_fuente_comentarios,(),main,programas = modulo1.leer_programas(),tupla_completa = modulo1.manejar_contenido(programas),archivos = modulo1.generar_csv(tupla_completa),with open('fuente_unico.csv','w') as f:,f.write(archivos[0]),with open('comentarios.csv','w') as c:,c.write(archivos[1]),
generar_csv,(tupla),modulo1,fuente_unico = '',comentarios = '',for funcion in tupla:,fuente_unico += funcion[0] + ',',comentarios += funcion[0] + ',',fuente_unico += funcion[1] + ',',comentarios +=  funcion[4][0] + ',',fuente_unico += funcion[2].strip('.py') + ',',for linea in funcion[3]:,fuente_unico += linea + ',',comentario_separado = separar_comentario(funcion[4][1:]),try:,comentarios += comentario_separado[0] +',',except TypeError:,comentarios+=',',try:,comentarios += comentario_separado[1] + ',',except TypeError:,comentarios += ',',fuente_unico += '\n',comentarios += '\n',return (fuente_unico,comentarios),
imprimir,(leyenda, dato, separador = False,contador_funciones='',porcentaje='',simbolo_porcentaje=''),corte_control,print('{} {} {} {} {}'.format(contador_funciones,leyenda, dato, porcentaje,simbolo_porcentaje)),if (separador):,guion = "=" * 55,print (guion,'\n'),
insercion,(lista),modulo1,n = len(lista),for i in range(1,n):,elemento = lista[i],max_local = i-1,while max_local >= 0 and elemento < lista[max_local]:,lista[max_local+1] = lista[max_local],max_local -= 1,lista[max_local+1] = elemento,return lista[:n-1],
leer,(archivo),corte_control,linea = archivo.readline(),if (not(linea)):,linea = MAX_LINEA,linea = linea.rstrip(),return linea.split(','),
leer_programas,(),modulo1,programa_num = 0,diccionario_salida = {},with open('programas.txt', encoding='utf-8') as p:,renglon = None,while renglon != '':,renglon = p.readline(),if renglon != '':,diccionario_salida['programa' +str(programa_num)] = renglon.strip('\n'),programa_num += 1,return diccionario_salida,
main,(),main,valor = None,while valor == None:,descripcion_menu(),valor = input(),if valor in '1,2,3,4,5,6'.split(','):,if valor == '1':,panel_general(),arch_datos = open("panel_general.csv", "r"),crear_panel_funciones.mostrar_tabla_funciones(arch_datos),arch_datos.close(),valor = None,if valor == '3':,An_Reu_Cod.reutilizacion_de_codigo(),valor = None,if valor == '5':,TPG_parte_5.ejecutar(),corte_control.main_control(),valor = None,if valor == '6':,print('''\nEsta opcion eliminara todos los archivos generados por el programa.,Luego, genera los archivos fuente_unico y comentarios que utilizan,los demas modulos. Esto permite analizar distintos programas,sin tener que eliminar los archivos correspondientes a los analisis anteriores.'''),sn = 'a',while sn not in 'sSnN':,sn = input('Desea continuar? (S/N) '),if sn.lower() == 's':,print('\nEliminando...'),os.remove("{}\\fuente_unico.csv".format(os.getcwd())),os.remove("{}\\comentarios.csv".format(os.getcwd())),if os.path.isfile("{}\\panel_general.csv".format(os.getcwd())):,os.remove("{}\\panel_general.csv".format(os.getcwd())),if os.path.isfile("{}\\analizador.txt".format(os.getcwd())):,os.remove("{}\\analizador.txt".format(os.getcwd())),generador_fuente_comentarios(),main(),elif valor not in '0,1,2,3,4,5,6'.split(','):,print('\nEl valor registrado no es un numero permitido!'),valor = None,else:,print('\nDesea eliminar los archivos generados por nuestro programa? (S/N)'),print('Esto no eliminara los archivos "fuente_unico" y "comentarios"\n'),sn = 'a',while sn not in 'sSnN':,sn = input(),if sn.lower() == 's':,print('\nEliminando...\n'),if os.path.isfile("{}\\panel_general.csv".format(os.getcwd())):,os.remove("{}\\panel_general.csv".format(os.getcwd())),if os.path.isfile("{}\\analizador.txt".format(os.getcwd())):,os.remove("{}\\analizador.txt".format(os.getcwd())),
main_control,(),corte_control,archivo = open(ARCHIVO,'r'),archivo_nuevo = open('participacion.txt','w'),contar_total(),corte_control(archivo,archivo_nuevo),archivo.close(),archivo_nuevo.close(),
manejar_contenido,(direcciones),modulo1,lista_final = [],for D in direcciones:,with open(direcciones[D], encoding='utf-8') as p:,programa = p.read().split('\n'),nombre_modulo = direcciones[D].split('\\')[-1],for funcion in ordenar_contenido(programa,nombre_modulo):,lista_final.append(funcion),lista_final = insercion(lista_final),return tuple(lista_final),
ordenar_contenido,(programa,nombre_mod),modulo1,lista_mod = [],comentarios = [],codigo = [],es_comentario = False,for linea in programa:,linea = linea.strip(),continue,if '\"\"\"' in linea:,if es_comentario and linea.count('\"\"\"') == 1:,es_comentario = False,elif linea.count('\"\"\"') == 1:,es_comentario = True,comentarios.append(linea),elif es_comentario:,if '[autor:' in linea.lower():,comentarios.insert(0,linea),else:,comentarios.append(linea),elif linea[0] == '#':,if comentarios != []:,comentarios.append(linea),elif linea.split()[0] == 'def':,nombre = linea.split('def ')[1].split('('),if len(lista_mod) > 0:,lista_mod[-1].append(tuple(codigo)),codigo = [],try:,if '[autor:' not in comentarios[0].lower():,comentarios.insert(0,'[Autor: ausente]'),except IndexError:,comentarios.append('[Autor: ausente]'),lista_mod[-1].append(tuple(comentarios)),comentarios = [],lista_mod.append([nombre[0],'('+nombre[1].strip(':'), nombre_mod]),else:,codigo.append(linea),if len(comentarios) == 0:,comentarios.append('[Autor: ausente]'),elif '[autor:' not in comentarios[0].lower():,comentarios.insert(0,'[Autor: ausente]'),lista_mod[-1].append(tuple(codigo)),lista_mod[-1].append(tuple(comentarios)),return lista_mod,
ordenar_por_autor,(),TPG_parte_5,parte_5 = {},f = open('fuente_unico.csv'),codigo = f.readline().split(',')[3:],codigo = len(arreglar.arreglar_csv(codigo)),c = open('comentarios.csv'),comentario = c.readline().split(',')[:2],parte_5[comentario[1]]={},autor= comentario[1],codigo_total=0,while comentario != ['']:,if autor != comentario[1] and comentario[1] not in parte_5:,parte_5[autor]['lineas_totales']= codigo_total,codigo_total=0,autor= comentario[1],parte_5[comentario[1]]={},parte_5[comentario[1]][comentario[0]]=codigo,codigo_total+= codigo,codigo = len(arreglar.arreglar_csv(f.readline().split(',')[3:])),comentario = c.readline().split(',')[:2],parte_5[autor]['lineas_totales']= codigo_total,parte_5 = sorted(parte_5.items(),key=lambda x:x[1]['lineas_totales'], reverse=True),return dict(parte_5),
panel_general,(),main,if not os.path.isfile("{}\\panel_general.csv".format(os.getcwd())):,f_error = "AAAAAA",arch_funcion_codigo = open("fuente_unico.csv", "r"),arch_funcion_coment = open("comentarios.csv", "r"),arch_datos_final = open("panel_general.csv", "w"),crear_arch_datos_funciones.cargar_datos(arch_funcion_codigo, arch_funcion_coment, arch_datos_final, f_error),arch_funcion_codigo.close(),arch_funcion_coment.close(),arch_datos_final.close(),generador_fuente_comentarios(),main(),
procesar_listaFP,(lfp, listaOG),An_Reu_Cod,sublistaLL = [],for linea in lfp:,llamada = None,paren = None,if linea is not lfp[0]:,try:,paren = linea.find('('),if '= ' in linea:,igual = linea.find('= ') + 2,elif '=' in linea:,igual = linea.find('=') + 1,else:,igual = 0,llamada = linea[igual:paren],except:,None,if llamada in listaOG:,sublistaLL.append(llamada),if paren != None:,del paren, igual, llamada, linea,else:,del llamada, linea, paren,return sublistaLL,
reutilizacion_de_codigo,(),An_Reu_Cod,if os.path.isfile("{}\\analizador.txt".format(os.getcwd())):,print('\nanalizador.txt existe, leyendo...\n'),print(),analizador = open("{}\\analizador.txt".format(os.getcwd()), 'r'),else:,print('\nanalizador.txt no existe, creando...\n'),listaOG = generador_de_lista_de_funciones(),listaLL = generador_de_listas_de_llamadas(listaOG),dixTOT = contador_de_invocaciones(listaOG, listaLL),dixRec = contador_de_llamadas(listaOG, dixTOT),txt_maker(listaOG, dixTOT, dixRec),del listaOG, listaLL, dixRec, dixTOT,print('analizador.txt creado, leyendo...\n'),print(),analizador = open("{}\\analizador.txt".format(os.getcwd()), 'r'),print(analizador.read()),analizador.close(),input('Pulse ENTER para finalizar.'),
separar_comentario,(comentarios),modulo1,es_importante = False,comentario_importante = '',comentario_normal = '',for linea in comentarios:,if '[Ayuda' in linea:,if ']' not in linea:,es_importante = True,comentario_importante += linea,elif es_importante == False:,comentario_normal += linea + ',',elif es_importante:,if ']' in linea:,es_importante = False,comentario_importante += linea,return(comentario_importante,comentario_normal),
suma_inv,(dixTOT, contador),An_Reu_Cod,suma_total = 0,for funcion in dixTOT:,suma_total += dixTOT[funcion][contador],return suma_total,
total_autor,(registro, archivo,archivo_nuevo),corte_control,autor, funcion, valor = autor_funcion_valor(registro),autor_actual = autor,funcion_actual = funcion,acumulado_autor   = 0,contador_funciones=0,print('{:^20}{:^40}'.format('Funciones','lineas')),archivo_nuevo.write('{:^20}{:^40} {}'.format('Funciones','lineas','\n')),while (autor == autor_actual and autor < MAX_AUTOR):,acumulado_funcion, funcion_procesado, registro = total_funcion(registro, archivo),leyenda = "  " + funcion_procesado + " - ",imprimir(leyenda, acumulado_funcion),escribir(leyenda, acumulado_funcion,archivo_nuevo),acumulado_autor  += acumulado_funcion,contador_funciones+=1,autor = registro[0],return acumulado_autor, registro, contador_funciones,
total_funcion,(registro, archivo),corte_control,autor, funcion, valor= autor_funcion_valor(registro),registro= leer(archivo),return valor, funcion, registro,
